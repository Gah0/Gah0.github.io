 # Instereing answer with gcc and clang compiler

![avatar](https://github.com/Gah0/Gah0.github.io/blob/master/images/caipeihua.png?raw=true)

此头像经室友同意上传，图片在我手中（笑

闲来无事搞C语言，天才室友问我(++I)+(++I)+(++I)在C语言怎么解，结果Vb得出答案是22，我就按照自己思路想，先自增后加法末赋值这样解释，其实我错了。  
于是换了个C语言编译器试了一下，太狗血了！    
室友说这个等于21
百度一看，Vscode其他编译器还有等于24的，草，答案都不正确吗？   
于是自己研究一番。。。   

**结果，其实大家都没有错！！！**  

CODE:

    #include "stdio.h"
    
    int main() {
    	int d=3;
    	printf("%d",(++i)+(++i)+(++i));
    	return 0;;
    }


**I GOT TWO VALUE FOR ANSWER!!**

GCC-7.4.0 COMPILER:

> $: gcc 运算符和表达式.c && ./a.out

> $:16


CLANG-8.1.0 COMPILER:
> $: clang 运算符和表达式.c && ./a.out

> $:15


#reversed assembly(AT&T format) 反汇编
**的确不是人看的代码**

`$: objdump -d a.out > gcc.dmp`

![avatar](https://github.com/Gah0/Gah0.github.io/blob/master/images/gcc.png?raw=true)

> 可以得出，先自增两次，相加，再自增，再相加，后赋值。
gcc是不是不符合规范？他并不像书上说的，自增比加号的优先级高。

------------
**我们来看看clang编译器怎么处理**
**Let's see clang compiler**

`$: objdump -d a.out > clang.dmp`

![avatar](https://github.com/Gah0/Gah0.github.io/blob/master/images/clang.png?raw=true)

> 我也得到clang的汇编结果，先自增，后相加，末赋值，严格按照了运算符规范！
---------

#结论
经过这次的工作，我了解了编译器工作原理。
还有解决了天才室友所提问的问题。
大神跟我说，任何一本合格的参考书书都会告诉你这是未定义行为。
我和他的答案都是正确的，只是编译器工作原理不同导致结果不一样
在汇编过程，我们发现，clang编译器经常调用内存堆栈和cpu寄存器，这可能导致开发板或手机性能下降。
据我了解，苹果手机系统开发和新的安卓系统编译几乎采用clang。这可能是个大趋势。
我以后编译内核仍然采取gcc，gcc唯一缺点就是缺少报错和编译缓慢。

