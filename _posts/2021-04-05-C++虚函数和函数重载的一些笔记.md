---
title: 虚函数和函数重载
comments: true
keywords: program
tags: [ C++,C,Tutorial ]
description: take some note
---
## 虚函数和函数重载



**函数重载**处理的是同一作用域中的同名函数；

- 函数名相同，参数不同
- 成员函数，友元函数，一般函数。
- 重载函数是静态联编static binding（编译时即可确定函数属于什么类）



**虚函数**处理的是不同派生类层次上的同名函数问题；

- 在基类和派生类的层次结构当中，~~非虚函数会输出以基类为主的同名函数内容~~
- 成员函数
- 虚函数是动态联编dynamic binding（晚期绑定）



#### 虚函数优点

软件开发商设计了各种各样的类，用户可以不知道基类怎么声明，自己在派生类写新的同名函数（即虚函数）。



#### 虚函数问题

[构造函数不能是虚函数? - 左轻侯的回答 - 知乎](https://www.zhihu.com/question/35632207/answer/63936329)







### 非多态性行为

```
class Employee{
public:
	display(){
		cout<<"employee"<<endl;
	}
};

class intern{
public:
	display(){
		cout<<"intern"<<endl;
	}
};
```

基类指针在非虚函数会在派生类中重新定义

```
Employee *pt = &emp1;
*pt ->display();
-------------------
$: employee
```

```
pt=&intern;
pt->display();
-------------------
$: intern
```

当指针指向一个纯虚函数，他才是动态关联，纯虚函数有解释。







### 虚析构函数

只在基类定义析构函数为virtual，系统会动态关联。

在基类上析构时会先析构派生类的析构函数。



### 纯虚函数

要在基类中保留该函数的定义，以便在各种派生类中实现不同的功能(多态性)。

例如基类中定义纯虚函数后，在circle类中定义`area()`求表面积，Cylinder类中`area()`求体积。

没有函数体

```c++

virtual float ShapeName() const = 0;
```



**动态关联**

```c++
pt = &circle;
pt->ShapeName();//基类的公共接口(抽象类)
cout<<pt->area()<<" m^2"<<endl;
-------------------
$: 2.0 m^2;
```





### 抽象类

- 有些类不是用于生成对象，他们的目的是给用户提供一种基本类型，或定义公共接口可以让其指针指向其他对象。

- 有**纯虚函数**就是一种**抽象类**。

- 基类声明了虚函数的话，派生类中有同名的函数均为重载**虚函数**。





