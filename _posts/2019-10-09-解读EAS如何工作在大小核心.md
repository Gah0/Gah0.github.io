>EAS是一种先进的，能源管理调度，它能根据节点数据和当前CPU负载，对arm处理器处理器进行升频，降频的操作。
>这将使得ARM芯片更加节省电能，很符合当下社会提倡的绿色环保理念。（HMP因为回调操作过慢，不符合能源效率的原因，被抛弃了。）

##前言
>15-18年的安卓手机，普遍使用HMP调度。换了小米9SE手机半年，深知EAS大法好。半年前我就开始移植EAS（伪）。
在移植EAS时，我发现这款手机处理器MSM8992（谷歌nexus5x也拥有此款EAS，由于机型淘汰后就不再维护）
在为我的小米4c老手机内核移植arm和linaro主导的Energy aware schedule，没仔细研读代码。
虽然前面是成功开机，但是在桌面滑动屏幕，或者cpu在heavy load时delay非常严重。
 昨晚研究了一个晚上，原来在唤醒进程或高负载情况下，内核默认使用CFS作为调速器，进入smp负载均衡，然而smp是平均把进程派发到所有核心，非常不利于大小核心处理器架构。
  
## 进程P如何进入能效合适的CPU！

EAS的精髓，在于唤醒进程时如何选择cpu。
###cpu overutilized()的说明
首先**cpu overutilized()**函数判断当前cpu上负载是否超过cpu上CFS调度类最大负载80%，这个负载值称为**tipping point**
###cpu overutilized()两种情况

-  [overutilize若触发了tipping point，则为队列负载过重，调用函数select_idle_sibling()，进入smp负载均衡算法]
-  [overutilize若没有触发了tipping point，让EAS做负载均衡，返回util。]

若触发了tipping point，则EAS调度器不会继续运行，而是走去了smp的道路上，而坑爹的是smp平均把进程派发所有核心，效益上不利于整体处理器的功耗。导致卡顿。小核心可能会CPU过载，最后也会导致进程P迁移。
###cpu overutilized()函数
/kernel/sched/fair.c
  ```
  /*overutilize的队列，用于判断当前cpu负载是否超过80%*/
  ...
  static bool cpu_overutilized(int cpu)
  {
	    return (capacity_of(cpu) * 1024) < (get_cpu_usage(cpu) * sysctl_sched_capacity_margin);
  }
  ...
  ```
因此，__避免触发overutilize是很重要的__，除了**cpu_overutilized**，在用于判断进程在就绪队列的负载函数**cpu_overutilized**前，还会有这三种情况


###在cpu_overutilized前面的三种情况


- cpu overutilized→enqueue_task_fair()
```
static void enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)
{
...
	if (!se) {
		walt_inc_cumulative_runnable_avg(rq, p);
		if (!task_new && !rq->rd->overutilized &&
		    cpu_overutilized(rq->cpu)) {
			rq->rd->overutilized = true;
			trace_sched_overutilized(true);
		}
...
```
- [cpu overutilized→task_tick_fair()]
```
static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)
{
...
#ifdef CONFIG_SMP
	if (!rq->rd->overutilized && cpu_overutilized(task_cpu(curr))) {
		rq->rd->overutilized = true;
		trace_sched_overutilized(true);
	}

	rq->misfit_task = !task_fits_max(curr, rq->cpu);
#endif
...
```
- [cpu overutilized→load_balance()→find_busiest_group()→update_sd_lb_stats]
```
static inline void update_sg_lb_stats(struct lb_env *env,
			struct sched_group *group, int load_idx,
			int local_group, struct sg_lb_stats *sgs,
			bool *overload, bool *overutilized)
}
...
		if (cpu_overutilized(i)) {
			*overutilized = true;
			if (!sgs->group_misfit_task && rq->misfit_task)
				sgs->group_misfit_task = capacity_of(i);
		}
...
```
    ```
  ...
  	if (!se) {
		  update_rq_runnable_avg(rq, rq->nr_running);
		  add_nr_running(rq, 1);
		  if (!task_new && !rq->rd->overutilized &&
		     cpu_overutilized(rq->cpu))
			 rq->rd->overutilized = true;
		 schedtune_enqueue_task(p, cpu_of(rq));
  ...
  ```
------------------------------
## EAS在没有触发tipping point的情况下，解决进程P分配。




[commit:8fbd5509cb1f7848a3e052d7315457ca6c77ff22][2]
[commit:1b8eae97d4a5b3f29c2ac56edce52897cb4dea07][1]
```
static int energy_aware_wake_cpu(struct task_struct *p, int target)
{
...
	if (sysctl_sched_is_big_little) {
		 do {
			 int max_cap_cpu = group_first_cpu(sg);
			 if (capacity_of(max_cap_cpu) < target_max_cap &&
			    task_fits_capacity(p, max_cap_cpu)) {
					 sg_target = sg;
					 target_max_cap = capacity_of(max_cap_cpu);
			 }
		 } while (sg = sg->next, sg != sd->groups);
...
		/* Not enough spare capacity on previous cpu */
		if (cpu_overutilized(task_cpu(p)))
			return target_cpu;

		if (energy_diff(&eenv) >= 0)
			return task_cpu(p);
	}
```
上面的循环，当if条件sysctl_sched_is_big_little成立时，
用while循环调度域里所包含的所有的调度组，寻造计算能力最为合适该进程P运行的调度组，假设调度组中所有CPU的计算能力都一样，task_fit_capacity()，在别的源码叫task_fits_max()，会判断调度组里的cpu计算能力是偶满足该进程计算能力要求。

```
static inline bool task_fits_capacity(struct task_struct *p, int cpu)
{
	unsigned long capacity = capacity_of(cpu);
	unsigned long max_capacity = cpu_rq(cpu)->rd->max_cpu_capacity;

	if (capacity == max_capacity)
		return true;

	if (capacity * sysctl_sched_capacity_margin > max_capacity * 1024)
		return true;

	return __task_fits(p, cpu, 0);
}
```
接下来的涉及到WALT(windows Assisted Load Tracking)算法，这是eas精髓，通过WALT算法返回一个demand值，从而找到一个计算能力最小的调度组。然后回到energy_aware_wake_cpu()函数，对比demand返回的uilt和new_uilt。


如果一个cpu当前计算能力大于进程的预期计算能力，且题调度组里面的cpu计算能力大于demand值125%，并且是计算能力最小的一个调度组，则把进程P抛入这个CPU里面去运行，任务不会不进行迁移。
```
static inline bool __task_fits(struct task_struct *p, int cpu, int util)
{
	unsigned long capacity = capacity_of(cpu);

	util += boosted_task_util(p);  //boosted_task_util(p)返回demand值

	return (capacity * 1024) > (util * capacity_margin);
}
```


这里讲述以下完整的EAS工作流程
**eenv**表示的是进程P在迁移之前的状态，迁移后的状态叫**eenv_after**，表示迁移到taget_cpu后
```
static inline int
energy_diff(struct energy_env *eenv)
{
	int boost = schedtune_task_boost(eenv->task);
	int nrg_delta;

	/* Conpute "absolute" energy diff */
	__energy_diff(eenv);

	/* Return energy diff when boost margin is 0 */
	if (boost == 0)
		return eenv->nrg.diff;

	/* Compute normalized energy diff */
	nrg_delta = normalize_energy(eenv->nrg.diff);
	eenv->nrg.delta = nrg_delta;

	eenv->payoff = schedtune_accept_deltas(
			eenv->nrg.delta,
			eenv->cap.delta,
			eenv->task);

	/*
	 * When SchedTune is enabled, the energy_diff() function will return
	 * the computed energy payoff value. Since the energy_diff() return
	 * value is expected to be negative by its callers, this evaluation
	 * function return a negative value each time the evaluation return a
	 * positive payoff, which is the condition for the acceptance of
	 * a scheduling decision
	 */
	return -eenv->payoff;
}
```

**sched_group_energy()**函数是根据group_die_0和group_die_1调度组里管辖CPU
EAS调度器功耗计算由busy和idle两种状态组成。
```
static int sched_group_energy(struct energy_env *eenv)
{
	struct sched_domain *sd;
	int cpu, total_energy = 0;
	struct cpumask visit_cpus;
	struct sched_group *sg;

	WARN_ON(!eenv->sg_top->sge);

	cpumask_copy(&visit_cpus, sched_group_cpus(eenv->sg_top));

	while (!cpumask_empty(&visit_cpus)) {
		struct sched_group *sg_shared_cap = NULL;

		cpu = cpumask_first(&visit_cpus);

		/*
		 * Is the group utilization affected by cpus outside this
		 * sched_group?
		 */
		sd = rcu_dereference(per_cpu(sd_scs, cpu));

		if (!sd)
			/*
			 * We most probably raced with hotplug; returning a
			 * wrong energy estimation is better than entering an
			 * infinite loop.
			 */
			return -EINVAL;

		if (sd->parent)
			sg_shared_cap = sd->parent->groups;

		for_each_domain(cpu, sd) {
			sg = sd->groups;

			/* Has this sched_domain already been visited? */
			if (sd->child && group_first_cpu(sg) != cpu)
				break;

			do {
				unsigned long group_util;
				int sg_busy_energy, sg_idle_energy;
				int cap_idx, idle_idx;

				if (sg_shared_cap && sg_shared_cap->group_weight >= sg->group_weight)
					eenv->sg_cap = sg_shared_cap;
				else
					eenv->sg_cap = sg;

				cap_idx = find_new_capacity(eenv, sg->sge);

				if (sg->group_weight == 1) {
					/* Remove capacity of src CPU (before task move) */
					if (eenv->util_delta == 0 &&
					    cpumask_test_cpu(eenv->src_cpu, sched_group_cpus(sg))) {
						eenv->cap.before = sg->sge->cap_states[cap_idx].cap;
						eenv->cap.delta -= eenv->cap.before;
					}
					/* Add capacity of dst CPU  (after task move) */
					if (eenv->util_delta != 0 &&
					    cpumask_test_cpu(eenv->dst_cpu, sched_group_cpus(sg))) {
						eenv->cap.after = sg->sge->cap_states[cap_idx].cap;
						eenv->cap.delta += eenv->cap.after;
					}
				}

				idle_idx = group_idle_state(sg);
				group_util = group_norm_util(eenv, sg);
				sg_busy_energy = (group_util * sg->sge->cap_states[cap_idx].power)
								>> SCHED_CAPACITY_SHIFT;
				sg_idle_energy = ((SCHED_LOAD_SCALE-group_util)
								* sg->sge->idle_states[idle_idx].power)
								>> SCHED_CAPACITY_SHIFT;

				total_energy += sg_busy_energy + sg_idle_energy;

				if (!sd->child)
					cpumask_xor(&visit_cpus, &visit_cpus, sched_group_cpus(sg));

				if (cpumask_equal(sched_group_cpus(sg), sched_group_cpus(eenv->sg_top)))
					goto next_cpu;

			} while (sg = sg->next, sg != sd->groups);
		}
next_cpu:
		cpumask_clear_cpu(cpu, &visit_cpus);
		continue;
	}

	eenv->energy = total_energy;
	return 0;
}
```

一个cluster的功耗计算方式，cluster是cpu集群的管理单元，也需要功耗
energy = cluster_energy+\sum\cpu_energy



好吧，好像文章写偏了，EAS在大小核心架构上大概工作的样子就是这样。

## 参考
[Big.little总结大全][3]
[魅族内核团队: sched对内核调用非常明显，可能会导致增加调度器负担增加！][4]

[1]:https://github.com/Gah0/android_kernel_xiaomi_libra/commit/1b8eae97d4a5b3f29c2ac56edce52897cb4dea07
[2]:https://github.com/Gah0/android_kernel_xiaomi_libra/commit/8fbd5509cb1f7848a3e052d7315457ca6c77ff22
[3]:https://github.com/gatieme/big.LITTLE
[4]:http://kernel.meizu.com/cpufreq-sched.html



