首先来看一道题

写一个算法，求下面序列之和：

​		-1，1，-1，1，...，（-1)^n

解法1；

```
sum = 0 ;
for(i=1; i<=n; i++)
​	sum=sum+pow(-1,n);
```

解法2；

```
if（n%2==0）
​	sum=0;
else
​	sum=-1;
```

> 解法一、解法二都是算法

好的算法标准是：

1. 正确性

2. 易读性

3. 健壮性

4. 高效性

5. 低存储性

   

如何保证代码高效？

> 时间复杂度：一般算法基本运算执行次数作为时间复杂度的量度标准。

```
sum=0；      				 //运行1次
total=0；					//运行1次
for(i=1;i<=n;i++) {  		  //运行n+1次，最后判断条件不成立，结束
​	sum=sum+i;				 //运行n次
​	for(j=1;j<=n;j++)		 //运行n*(n+1)次
​		total=total+i*j;	 //运行n*n次
}
```

> 算法语句加起来，即1+1+n+1+n+n(n+1)+ n*n，用一个函数表达：

$$
T(n)=2n^2+3n+3
$$

用极限表示：
$$
lim(n->无穷) T(n)/f(n)= c   (c≠0)
$$
想想T(n)图像，一元二次函数图：

是不是有T(n)和c*f(n)之间有个关系呢？

我们比较他们的“**相对增长率**”，我的理解是“斜率"

O(f(n))来表示**时间复杂度渐进上界**，通常用这种表示法衡量算法时间复杂度。



再来一个

```
i=1;          	//运行1次
while(i<=n) {	//运行x次
	i=i*2;	    //运行x次
}
```

i值：2, 2^2, 2^3, ..., 2^x

当i=n时，即2^x=n结束，x=log2(n)，运算次数为1+2log2(n)，时间复杂度渐进上界为O(f(n))=O(log2(n))。

像查找数组位置这些代码是不能直接计算运算次数的。执行次数依赖于x在数组中的位置。有些算法可以用**最好情况**，**最坏情况**和**平均情况**分别求算法复杂度。最坏情况对决策有关键作用。





